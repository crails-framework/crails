#include <sstream>
#include "crails/render_target.hpp"
#include "crails/shared_vars.hpp"
#include "crails/template.hpp"

class render_SidekixCtplH : public Crails::Template
{
public:
  render_SidekixCtplH(const Crails::Renderer& renderer, Crails::RenderTarget& target, Crails::SharedVars& vars) :
    Crails::Template(renderer, target, vars)
  {}

  void render()
  {
ecpp_stream << "\n/*********************************************************\n *\n *  Copyright (C) 2014 by Vitaliy Vitsentiy\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *********************************************************/\n\n\n#ifndef __ctpl_thread_pool_H__\n#define __ctpl_thread_pool_H__\n\n#include <functional>\n#include <thread>\n#include <atomic>\n#include <vector>\n#include <memory>\n#include <exception>\n#include <future>\n#include <mutex>\n#include <boost/lockfree/queue.hpp>\n\n\n#ifndef _ctplThreadPoolLength_\n#define _ctplThreadPoolLength_  100\n#endif\n\n\n// thread pool to run user's functors with signature\n//      ret func(int id, other_params)\n// where id is the index of the thread that runs the functor\n// ret is some return type\n\n\nnamespace ctpl {\n\n    class thread_pool {\n\n    public:\n\n        thread_pool() : q(_ctplThreadPoolLength_) { this->init(); }\n        thread_pool(int nThreads, int queueSize = _ctplThreadPoolLength_) : q(queueSize) { this->init(); this->resize(nThreads); }\n\n        // the destructor waits for all the functions in the queue to be finished\n        ~thread_pool() {\n            this->stop(true);\n        }\n\n        // get the number of running threads in the pool\n        int size() { return static_cast<int>(this->threads.size()); }\n\n        // number of idle threads\n        int n_idle() { return this->nWaiting; }\n        std::thread & get_thread(int i) { return *this->threads[i]; }\n\n        // change the number of threads in the pool\n        // should be called from one thread, otherwise be careful to not interleave, also with this->stop()\n        // nThreads must be >= 0\n        void resize(int nThreads) {\n            if (!this->isStop && !this->isDone) {\n                int oldNThreads = static_cast<int>(this->threads.size());\n                if (oldNThreads <= nThreads) {  // if the number of threads is increased\n                    this->threads.resize(nThreads);\n                    this->flags.resize(nThreads);\n\n                    for (int i = oldNThreads; i < nThreads; ++i) {\n                        this->flags[i] = std::make_shared<std::atomic<bool>>(false);\n                        this->set_thread(i);\n                    }\n                }\n                else {  // the number of threads is decreased\n                    for (int i = oldNThreads - 1; i >= nThreads; --i) {\n                        *this->flags[i] = true;  // this thread will finish\n                        this->threads[i]->detach();\n                    }\n                    {\n                        // stop the detached threads that were waiting\n                        std::unique_lock<std::mutex> lock(this->mutex);\n                        this->cv.notify_all();\n                    }\n                    this->threads.resize(nThreads);  // safe to delete because the threads are detached\n                    this->flags.resize(nThreads);  // safe to delete because the threads have copies of shared_ptr of the flags, not originals\n                }\n            }\n        }\n\n        // empty the queue\n        void clear_queue() {\n            std::function<void(int id)> * _f;\n            while (this->q.pop(_f))\n                delete _f;  // empty the queue\n        }\n\n        // pops a functional wraper to the original function\n        std::function<void(int)> pop() {\n            std::function<void(int id)> * _f = nullptr;\n            this->q.pop(_f);\n            std::unique_ptr<std::function<void(int id)>> func(_f);  // at return, delete the function even if an exception occurred\n\n            std::function<void(int)> f;\n            if (_f)\n                f = *_f;\n            return f;\n        }\n\n\n        // wait for all computing threads to finish and stop all threads\n        // may be called asyncronously to not pause the calling thread while waiting\n        // if isWait == true, all the functions in the queue are run, otherwise the queue is cleared without running the functions\n        void stop(bool isWait = false) {\n            if (!isWait) {\n                if (this->isStop)\n                    return;\n                this->isStop = true;\n                for (int i = 0, n = this->size(); i < n; ++i) {\n                    *this->flags[i] = true;  // command the threads to stop\n                }\n                this->clear_queue();  // empty the queue\n            }\n            else {\n                if (this->isDone || this->isStop)\n                    return;\n                this->isDone = true;  // give the waiting threads a command to finish\n            }\n            {\n                std::unique_lock<std::mutex> lock(this->mutex);\n                this->cv.notify_all();  // stop all waiting threads\n            }\n            for (int i = 0; i < static_cast<int>(this->threads.size()); ++i) {  // wait for the computing threads to finish\n                if (this->threads[i]->joinable())\n                    this->threads[i]->join();\n            }\n            // if there were no threads in the pool but some functors in the queue, the functors are not deleted by the threads\n            // therefore delete them here\n            this->clear_queue();\n            this->threads.clear();\n            this->flags.clear();\n        }\n\n        template<typename F, typename... Rest>\n        auto push(F && f, Rest&&... rest) ->std::future<decltype(f(0, rest...))> {\n            auto pck = std::make_shared<std::packaged_task<decltype(f(0, rest...))(int)>>(\n                std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Rest>(rest)...)\n            );\n\n            auto _f = new std::function<void(int id)>([pck](int id) {\n                (*pck)(id);\n            });\n            this->q.push(_f);\n\n            std::unique_lock<std::mutex> lock(this->mutex);\n            this->cv.notify_one();\n\n            return pck->get_future();\n        }\n\n        // run the user's function that excepts argument int - id of the running thread. returned value is templatized\n        // operator returns std::future, where the user can get the result and rethrow the catched exceptins\n        template<typename F>\n        auto push(F && f) ->std::future<decltype(f(0))> {\n            auto pck = std::make_shared<std::packaged_task<decltype(f(0))(int)>>(std::forward<F>(f));\n\n            auto _f = new std::function<void(int id)>([pck](int id) {\n                (*pck)(id);\n            });\n            this->q.push(_f);\n\n            std::unique_lock<std::mutex> lock(this->mutex);\n            this->cv.notify_one();\n\n            return pck->get_future();\n        }\n\n\n    private:\n\n        // deleted\n        thread_pool(const thread_pool &);// = delete;\n        thread_pool(thread_pool &&);// = delete;\n        thread_pool & operator=(const thread_pool &);// = delete;\n        thread_pool & operator=(thread_pool &&);// = delete;\n\n        void set_thread(int i) {\n            std::shared_ptr<std::atomic<bool>> flag(this->flags[i]);  // a copy of the shared ptr to the flag\n            auto f = [this, i, flag/* a copy of the shared ptr to the flag */]() {\n                std::atomic<bool> & _flag = *flag;\n                std::function<void(int id)> * _f;\n                bool isPop = this->q.pop(_f);\n                while (true) {\n                    while (isPop) {  // if there is anything in the queue\n                        std::unique_ptr<std::function<void(int id)>> func(_f);  // at return, delete the function even if an exception occurred\n                        (*_f)(i);\n\n                        if (_flag)\n                            return;  // the thread is wanted to stop, return even if the queue is not empty yet\n                        else\n                            isPop = this->q.pop(_f);\n                    }\n\n                    // the queue is empty here, wait for the next command\n                    std::unique_lock<std::mutex> lock(this->mutex);\n                    ++this->nWaiting;\n                    this->cv.wait(lock, [this, &_f, &isPop, &_flag](){ isPop = this->q.pop(_f); return isPop || this->isDone || _flag; });\n                    --this->nWaiting;\n\n                    if (!isPop)\n                        return;  // if the queue is empty and this->isDone == true or *flag then return\n                }\n            };\n            this->threads[i].reset(new std::thread(f));  // compiler may not support std::make_unique()\n        }\n\n        void init() { this->nWaiting = 0; this->isStop = false; this->isDone = false; }\n\n        std::vector<std::unique_ptr<std::thread>> threads;\n        std::vector<std::shared_ptr<std::atomic<bool>>> flags;\n        mutable boost::lockfree::queue<std::function<void(int id)> *> q;\n        std::atomic<bool> isDone;\n        std::atomic<bool> isStop;\n        std::atomic<int> nWaiting;  // how many threads are waiting\n\n        std::mutex mutex;\n        std::condition_variable cv;\n    };\n\n}\n\n#endif // __ctpl_thread_pool_H__\n";
    this->target.set_body(ecpp_stream.str());
  }
private:
  std::stringstream ecpp_stream;
};

void render_sidekix_ctpl_h(const Crails::Renderer& renderer, Crails::RenderTarget& target, Crails::SharedVars& vars)
{
  render_SidekixCtplH(renderer, target, vars).render();
}